#include "BMI088.h"
#include <Wire.h>
#include "RTClib.h"
#include <SPI.h>
#include <SD.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_BME280.h>
#include <Adafruit_GPS.h>
#include <Arduino.h>
#include <LoRa.h>

#define SEALEVELPRESSURE_HPA (1006.2)
#define GPSSerial Serial1
#define GPSECHO false

Adafruit_GPS GPS(&GPSSerial);
Adafruit_BME280 bme;
RTC_PCF8523 rtc;
File SDFile;

uint32_t timer = millis();

const int csPin = 17;        
const int resetPin = 21;    
const int irqPin = 20;       
const int _MISO = 8;
const int _MOSI = 11;
const int _CS = 9;
const int _SCK = 10;

float lastMillis, currentMillis, gz, gx, gy, gzS, gxS, gyS;
String dateStamp, Packet, IMU, BME, GPSVal, outgoing, receivedData, myGPS;
int status;
int packetId = 0; // Incrementing packet ID

Bmi088Accel accel(Wire, 0x19);
Bmi088Gyro gyro(Wire, 0x69);

void setup() {
  GPS.begin(9600);
  GPS.sendCommand(PMTK_SET_NMEA_OUTPUT_RMCGGA);
  GPS.sendCommand(PMTK_SET_NMEA_UPDATE_1HZ);
  GPS.sendCommand(PGCMD_ANTENNA);
  GPSSerial.println(PMTK_Q_RELEASE);

  char c = GPS.read();
  if (GPSECHO && c) Serial.print(c);

  if (GPS.newNMEAreceived()) {
    if (GPS.parse(GPS.lastNMEA())) {
      if (GPS.fix) {
        GPSVal = formatGPSData();
        char buffer[GPSVal.length() + 1];
        GPSVal.toCharArray(buffer, sizeof(buffer));
        for (int i = 0; i < GPSVal.length(); i++) {
          rp2040.fifo.push(buffer[i]);
        }
      }
    }
  }
}

void loop() {
  char c = GPS.read();
  if (GPSECHO && c) Serial.print(c);

  if (GPS.newNMEAreceived()) {
    if (!GPS.parse(GPS.lastNMEA())) return;
  }

  if (millis() - timer > 2000) {
    timer = millis();
    if (GPS.fix) {
      GPSVal = formatGPSData();
      char buffer[GPSVal.length() + 1];
      GPSVal.toCharArray(buffer, sizeof(buffer));
      for (int i = 0; i < GPSVal.length(); i++) {
        rp2040.fifo.push(buffer[i]);
      }
    }
  }
}

void setup1() {
  Serial.begin(115200); // Optional debugging, no wait

  pinMode(12, OUTPUT);
  pinMode(13, OUTPUT);
  pinMode(14, OUTPUT);

  SPI.setRX(16);
  SPI.setTX(19);
  SPI.setSCK(18);
  LoRa.setSPI(SPI);
  LoRa.enableCrc();
  LoRa.setPins(csPin, resetPin, irqPin);

  if (!LoRa.begin(915E6)) {
    digitalWrite(12, HIGH);
    while (1);
  }

  SPI1.setRX(_MISO);
  SPI1.setTX(_MOSI);
  SPI1.setSCK(_SCK);
  
  if (!bme.begin(0x76, &Wire)) {
    digitalWrite(13, HIGH);
    while (1);
  }

  if (!SD.begin(_CS, SPI1)) {
    digitalWrite(14, HIGH);
    while (1);
  }
  SDFile = SD.open("data.txt", FILE_WRITE);
  if (!SDFile) {
    digitalWrite(14, HIGH);
    while (1);
  }

  status = accel.begin();
  if (status < 0) {
    digitalWrite(13, HIGH);
    while (1);
  }
  status = gyro.begin();
  if (status < 0) {
    digitalWrite(13, HIGH);
    while (1);
  }

  if (!rtc.begin() || !rtc.initialized() || rtc.lostPower()) {
    rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
  }
  rtc.start();

  sendInitialData();
}

void loop1() {
  DateTime now = rtc.now();
  currentMillis = millis();
  accel.readSensor();
  gyro.readSensor();
  
  gxS = (1.0 - 0.01) * gxS + 0.01 * gyro.getGyroX_rads();
  gyS = (1.0 - 0.01) * gyS + 0.01 * gyro.getGyroY_rads();
  gzS = (1.0 - 0.01) * gzS + 0.01 * gyro.getGyroZ_rads();

  gx += (gxS < 0.0006 && gxS > -0.0006 ? 0.00f : gxS) * 2;
  gy += (gyS < 0.0006 && gyS > -0.0006 ? 0.00f : gyS) * 2;
  gz += (gzS < 0.0006 && gzS > -0.0006 ? 0.00f : gzS) * 2;

  Packet = formatPacket(now);
  sendMessage(Packet);
  SDFile.println(Packet);
  SDFile.flush();

  onReceive(LoRa.parsePacket());
  delay(2000);
}

String formatPacket(DateTime now) {
  String packet = "[";
  packet += "id:" + String(packetId++) + ",";
  packet += "mission_time:" + String(now.year(), DEC) + "/" + String(now.month(), DEC) + "/" + 
            String(now.day(), DEC) + " " + String(now.hour(), DEC) + ":" + 
            String(now.minute(), DEC) + ":" + String(now.second(), DEC) + ",";
  packet += "connected:1,"; // Assume connected if transmitting
  packet += "acceleration_x:" + String(accel.getAccelX_mss()) + ",";
  packet += "acceleration_y:" + String(accel.getAccelY_mss()) + ",";
  packet += "acceleration_z:" + String(accel.getAccelZ_mss()) + ",";
  packet += "velocity_x:0,"; // Not calculated, set to 0
  packet += "velocity_y:0,";
  packet += "velocity_z:0,";
  packet += "pitch:" + String(round(gy)) + ","; // Using gyro-integrated values
  packet += "roll:" + String(round(gx)) + ",";
  packet += "yaw:" + String(round(gz)) + ",";
  packet += "mag_x:0,"; // No magnetometer
  packet += "mag_y:0,";
  packet += "mag_z:0,";
  packet += "baro_press:" + String(bme.readPressure() / 100.0F) + ",";
  packet += "altitude:" + String(bme.readAltitude(SEALEVELPRESSURE_HPA)) + ",";
  packet += "press:" + String(bme.readPressure() / 100.0F) + ","; // Duplicate of baro_press
  packet += "temp:" + String(bme.readTemperature()) + ",";
  packet += "battery:0,"; // No battery data
  packet += "minute:" + String(now.minute(), DEC) + ",";
  packet += "second:" + String(now.second(), DEC) + ",";

  receivedData = "";
  while (rp2040.fifo.available()) {
    receivedData += (char)rp2040.fifo.pop();
  }
  if (receivedData != "" && receivedData != myGPS) {
    myGPS = receivedData;
  }
  packet += myGPS.length() > 0 ? myGPS : "latitude:0,longitude:0,satellites:0,";

  packet += "]"; // Close bracket
  packet += ",rssi:" + String(LoRa.packetRssi()); // Append RSSI

  if (packet.length() > 255) {
    packet = packet.substring(0, 255);
  }
  return packet;
}

String formatGPSData() {
  return "latitude:" + ddmmToDD(String(GPS.latitude, 4), GPS.lat) + "," +
         "longitude:" + ddmmToDD(String(GPS.longitude, 4), GPS.lon) + "," +
         "satellites:" + String((int)GPS.satellites) + ",";
}

void sendInitialData() {
  DateTime now = rtc.now();
  accel.readSensor();
  gyro.readSensor();

  gxS = gyro.getGyroX_rads();
  gyS = gyro.getGyroY_rads();
  gzS = gyro.getGyroZ_rads();
  gx = gxS * 2;
  gy = gyS * 2;
  gz = gzS * 2;

  Packet = formatPacket(now);
  sendMessage(Packet);
  SDFile.println(Packet);
  SDFile.flush();
}

void sendMessage(String outgoing) {
  LoRa.beginPacket();
  LoRa.write(outgoing.length());
  LoRa.print(outgoing);
  LoRa.endPacket();
}

void onReceive(int packetSize) {
  if (packetSize == 0) return;

  byte incomingLength = LoRa.read();
  String incoming = "";
  while (LoRa.available()) {
    incoming += (char)LoRa.read();
  }
}

String ddmmToDD(String raw_gps, char lat) {
  float val = raw_gps.toFloat();
  float deg = int(val / 100);
  float min = (val - deg * 100) / 60;
  float result = deg + min;
  return (lat == 'N' || lat == 'E') ? String(result, 6) : String(-result, 6);
}
